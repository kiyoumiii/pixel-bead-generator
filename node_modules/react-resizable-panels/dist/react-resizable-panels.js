"use client";
import { jsx as B } from "react/jsx-runtime";
import { useState as K, useCallback as Pe, useId as Ue, useLayoutEffect as We, useEffect as Re, useRef as k, createContext as Be, useImperativeHandle as Ce, useMemo as ae, useSyncExternalStore as Ke, useContext as Xe } from "react";
function z(e, t = "Assertion error") {
  if (!e)
    throw Error(t);
}
function V({
  group: e
}) {
  const { orientation: t, panels: n } = e;
  return n.reduce((o, i) => (o += t === "horizontal" ? i.element.offsetWidth : i.element.offsetHeight, o), 0);
}
function le(e, t) {
  return t.sort(
    e === "horizontal" ? qe : Ye
  );
}
function qe(e, t) {
  const n = e.element.offsetLeft - t.element.offsetLeft;
  return n !== 0 ? n : e.element.offsetWidth - t.element.offsetWidth;
}
function Ye(e, t) {
  const n = e.element.offsetTop - t.element.offsetTop;
  return n !== 0 ? n : e.element.offsetHeight - t.element.offsetHeight;
}
function Me(e) {
  return e !== null && typeof e == "object" && "nodeType" in e && e.nodeType === Node.ELEMENT_NODE;
}
function Ee(e, t) {
  return {
    x: e.x >= t.left && e.x <= t.right ? 0 : Math.min(
      Math.abs(e.x - t.left),
      Math.abs(e.x - t.right)
    ),
    y: e.y >= t.top && e.y <= t.bottom ? 0 : Math.min(
      Math.abs(e.y - t.top),
      Math.abs(e.y - t.bottom)
    )
  };
}
function Je({
  orientation: e,
  rects: t,
  targetRect: n
}) {
  const o = {
    x: n.x + n.width / 2,
    y: n.y + n.height / 2
  };
  let i, a = Number.MAX_VALUE;
  for (const l of t) {
    const { x: r, y: s } = Ee(o, l), u = e === "horizontal" ? r : s;
    u < a && (a = u, i = l);
  }
  return z(i, "No rect found"), i;
}
function ke(e) {
  const { element: t, orientation: n, panels: o, separators: i } = e, a = le(
    n,
    Array.from(t.children).filter(Me).map((f) => ({ element: f }))
  ).map(({ element: f }) => f), l = [];
  let r = !1, s, u = [];
  for (const f of a)
    if (f.hasAttribute("data-panel")) {
      const p = o.find(
        (h) => h.element === f
      );
      if (p) {
        if (s) {
          const h = s.element.getBoundingClientRect(), m = f.getBoundingClientRect();
          let c;
          if (r) {
            const d = n === "horizontal" ? new DOMRect(h.right, h.top, 0, h.height) : new DOMRect(
              h.left,
              h.bottom,
              h.width,
              0
            ), S = n === "horizontal" ? new DOMRect(m.left, m.top, 0, m.height) : new DOMRect(m.left, m.top, m.width, 0);
            switch (u.length) {
              case 0: {
                c = [
                  d,
                  S
                ];
                break;
              }
              case 1: {
                const y = u[0], v = Je({
                  orientation: n,
                  rects: [h, m],
                  targetRect: y.element.getBoundingClientRect()
                });
                c = [
                  y,
                  v === h ? S : d
                ];
                break;
              }
              default: {
                c = u;
                break;
              }
            }
          } else
            u.length ? c = u : c = [
              n === "horizontal" ? new DOMRect(
                h.right,
                m.top,
                m.left - h.right,
                m.height
              ) : new DOMRect(
                m.left,
                h.bottom,
                m.width,
                m.top - h.bottom
              )
            ];
          for (const d of c)
            l.push({
              group: e,
              groupSize: V({ group: e }),
              panels: [s, p],
              separator: "width" in d ? void 0 : d,
              rect: "width" in d ? d : d.element.getBoundingClientRect()
            });
        }
        r = !1, s = p, u = [];
      }
    } else if (f.hasAttribute("data-separator")) {
      const p = i.find(
        (h) => h.element === f
      );
      p ? u.push(p) : (s = void 0, u = []);
    } else
      r = !0;
  return l;
}
function Ze(e, t) {
  const n = getComputedStyle(e), o = parseFloat(n.fontSize);
  return t * o;
}
function Qe(e, t) {
  const n = getComputedStyle(e.ownerDocument.body), o = parseFloat(n.fontSize);
  return t * o;
}
function et(e) {
  return e / 100 * window.innerHeight;
}
function tt(e) {
  return e / 100 * window.innerWidth;
}
function nt(e) {
  switch (typeof e) {
    case "number":
      return [e, "px"];
    case "string": {
      const t = parseFloat(e);
      return e.endsWith("%") ? [t, "%"] : e.endsWith("px") ? [t, "px"] : e.endsWith("rem") ? [t, "rem"] : e.endsWith("em") ? [t, "em"] : e.endsWith("vh") ? [t, "vh"] : e.endsWith("vw") ? [t, "vw"] : [t, "%"];
    }
  }
}
function Z({
  groupSize: e,
  panelElement: t,
  styleProp: n
}) {
  let o;
  const [i, a] = nt(n);
  switch (a) {
    case "%": {
      o = i / 100 * e;
      break;
    }
    case "px": {
      o = i;
      break;
    }
    case "rem": {
      o = Qe(t, i);
      break;
    }
    case "em": {
      o = Ze(t, i);
      break;
    }
    case "vh": {
      o = et(i);
      break;
    }
    case "vw": {
      o = tt(i);
      break;
    }
  }
  return o;
}
function G(e) {
  return parseFloat(e.toFixed(3));
}
function pe(e) {
  const { panels: t } = e, n = V({ group: e });
  return n === 0 ? t.map((o) => ({
    collapsedSize: 0,
    collapsible: o.panelConstraints.collapsible === !0,
    defaultSize: void 0,
    minSize: 0,
    maxSize: 100,
    panelId: o.id
  })) : t.map((o) => {
    const { element: i, panelConstraints: a } = o;
    let l = 0;
    if (a.collapsedSize) {
      const f = Z({
        groupSize: n,
        panelElement: i,
        styleProp: a.collapsedSize
      });
      l = G(f / n * 100);
    }
    let r;
    if (a.defaultSize) {
      const f = Z({
        groupSize: n,
        panelElement: i,
        styleProp: a.defaultSize
      });
      r = G(f / n * 100);
    }
    let s = 0;
    if (a.minSize) {
      const f = Z({
        groupSize: n,
        panelElement: i,
        styleProp: a.minSize
      });
      s = G(f / n * 100);
    }
    let u = 100;
    if (a.maxSize) {
      const f = Z({
        groupSize: n,
        panelElement: i,
        styleProp: a.maxSize
      });
      u = G(f / n * 100);
    }
    return {
      collapsedSize: l,
      collapsible: a.collapsible === !0,
      defaultSize: r,
      minSize: s,
      maxSize: u,
      panelId: o.id
    };
  });
}
class ot {
  #e = {};
  addListener(t, n) {
    const o = this.#e[t];
    return o === void 0 ? this.#e[t] = [n] : o.includes(n) || o.push(n), () => {
      this.removeListener(t, n);
    };
  }
  emit(t, n) {
    const o = this.#e[t];
    if (o !== void 0)
      if (o.length === 1)
        o[0].call(null, n);
      else {
        let i = !1, a = null;
        const l = Array.from(o);
        for (let r = 0; r < l.length; r++) {
          const s = l[r];
          try {
            s.call(null, n);
          } catch (u) {
            a === null && (i = !0, a = u);
          }
        }
        if (i)
          throw a;
      }
  }
  removeAllListeners() {
    this.#e = {};
  }
  removeListener(t, n) {
    const o = this.#e[t];
    if (o !== void 0) {
      const i = o.indexOf(n);
      i >= 0 && o.splice(i, 1);
    }
  }
}
function M(e, t, n = 0) {
  return Math.abs(G(e) - G(t)) <= n;
}
let E = {
  cursorFlags: 0,
  interactionState: {
    state: "inactive"
  },
  mountedGroups: /* @__PURE__ */ new Map()
};
const A = new ot();
function D() {
  return E;
}
function I(e) {
  const t = typeof e == "function" ? e(E) : e;
  if (E === t)
    return E;
  const n = E;
  return E = {
    ...E,
    ...t
  }, t.cursorFlags !== void 0 && A.emit("cursorFlagsChange", E.cursorFlags), t.interactionState !== void 0 && A.emit("interactionStateChange", E.interactionState), t.mountedGroups !== void 0 && (E.mountedGroups.forEach((o, i) => {
    o.derivedPanelConstraints.forEach((a) => {
      if (a.collapsible) {
        const { layout: l } = n.mountedGroups.get(i) ?? {};
        if (l) {
          const r = M(
            a.collapsedSize,
            o.layout[a.panelId]
          ), s = M(
            a.collapsedSize,
            l[a.panelId]
          );
          r && !s && (i.inMemoryLastExpandedPanelSizes[a.panelId] = l[a.panelId]);
        }
      }
    });
  }), A.emit("mountedGroupsChange", E.mountedGroups)), E;
}
function rt(e, t) {
  if (e.length !== t.length)
    return !1;
  for (let n = 0; n < e.length; n++)
    if (e[n] != t[n])
      return !1;
  return !0;
}
function X(e, t) {
  return M(e, t) ? 0 : e > t ? 1 : -1;
}
function H({
  panelConstraints: e,
  size: t
}) {
  const {
    collapsedSize: n = 0,
    collapsible: o,
    maxSize: i = 100,
    minSize: a = 0
  } = e;
  if (X(t, a) < 0)
    if (o) {
      const l = (n + a) / 2;
      X(t, l) < 0 ? t = n : t = a;
    } else
      t = a;
  return t = Math.min(i, t), t = G(t), t;
}
function q({
  delta: e,
  initialLayout: t,
  panelConstraints: n,
  pivotIndices: o,
  prevLayout: i,
  trigger: a
}) {
  if (M(e, 0))
    return t;
  const l = Object.values(t), r = Object.values(i), s = [...l], [u, f] = o;
  z(u != null, "Invalid first pivot index"), z(f != null, "Invalid second pivot index");
  let p = 0;
  if (a === "keyboard") {
    {
      const c = e < 0 ? f : u, d = n[c];
      z(
        d,
        `Panel constraints not found for index ${c}`
      );
      const {
        collapsedSize: S = 0,
        collapsible: y,
        minSize: v = 0
      } = d;
      if (y) {
        const x = l[c];
        if (z(
          x != null,
          `Previous layout not found for panel index ${c}`
        ), M(x, S)) {
          const g = v - x;
          X(g, Math.abs(e)) > 0 && (e = e < 0 ? 0 - g : g);
        }
      }
    }
    {
      const c = e < 0 ? u : f, d = n[c];
      z(
        d,
        `No panel constraints found for index ${c}`
      );
      const {
        collapsedSize: S = 0,
        collapsible: y,
        minSize: v = 0
      } = d;
      if (y) {
        const x = l[c];
        if (z(
          x != null,
          `Previous layout not found for panel index ${c}`
        ), M(x, v)) {
          const g = x - S;
          X(g, Math.abs(e)) > 0 && (e = e < 0 ? 0 - g : g);
        }
      }
    }
  }
  {
    const c = e < 0 ? 1 : -1;
    let d = e < 0 ? f : u, S = 0;
    for (; ; ) {
      const v = l[d];
      z(
        v != null,
        `Previous layout not found for panel index ${d}`
      );
      const g = H({
        panelConstraints: n[d],
        size: 100
      }) - v;
      if (S += g, d += c, d < 0 || d >= n.length)
        break;
    }
    const y = Math.min(Math.abs(e), Math.abs(S));
    e = e < 0 ? 0 - y : y;
  }
  {
    let d = e < 0 ? u : f;
    for (; d >= 0 && d < n.length; ) {
      const S = Math.abs(e) - Math.abs(p), y = l[d];
      z(
        y != null,
        `Previous layout not found for panel index ${d}`
      );
      const v = y - S, x = H({
        panelConstraints: n[d],
        size: v
      });
      if (!M(y, x) && (p += y - x, s[d] = x, p.toFixed(3).localeCompare(Math.abs(e).toFixed(3), void 0, {
        numeric: !0
      }) >= 0))
        break;
      e < 0 ? d-- : d++;
    }
  }
  if (rt(r, s))
    return i;
  {
    const c = e < 0 ? f : u, d = l[c];
    z(
      d != null,
      `Previous layout not found for panel index ${c}`
    );
    const S = d + p, y = H({
      panelConstraints: n[c],
      size: S
    });
    if (s[c] = y, !M(y, S)) {
      let v = S - y, g = e < 0 ? f : u;
      for (; g >= 0 && g < n.length; ) {
        const L = s[g];
        z(
          L != null,
          `Previous layout not found for panel index ${g}`
        );
        const P = L + v, R = H({
          panelConstraints: n[g],
          size: P
        });
        if (M(L, R) || (v -= R - L, s[g] = R), M(v, 0))
          break;
        e > 0 ? g-- : g++;
      }
    }
  }
  const h = Object.values(s).reduce(
    (c, d) => d + c,
    0
  );
  if (!M(h, 100, 0.1))
    return i;
  const m = Object.keys(i);
  return s.reduce((c, d, S) => (c[m[S]] = d, c), {});
}
function ee(e) {
  const { mountedGroups: t } = D();
  for (const [n] of t)
    if (n.separators.some(
      (o) => o.element === e
    ))
      return n;
  throw Error("Could not find parent Group for separator element");
}
function U(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const n in e)
    if (t[n] === void 0 || X(e[n], t[n]) !== 0)
      return !1;
  return !0;
}
function F({
  layout: e,
  panelConstraints: t
}) {
  const o = [...Object.values(e)], i = o.reduce(
    (r, s) => r + s,
    0
  );
  if (o.length !== t.length)
    throw Error(
      `Invalid ${t.length} panel layout: ${o.map((r) => `${r}%`).join(", ")}`
    );
  if (!M(i, 100) && o.length > 0)
    for (let r = 0; r < t.length; r++) {
      const s = o[r];
      z(s != null, `No layout data found for index ${r}`);
      const u = 100 / i * s;
      o[r] = u;
    }
  let a = 0;
  for (let r = 0; r < t.length; r++) {
    const s = o[r];
    z(s != null, `No layout data found for index ${r}`);
    const u = H({
      panelConstraints: t[r],
      size: s
    });
    s != u && (a += s - u, o[r] = u);
  }
  if (!M(a, 0))
    for (let r = 0; r < t.length; r++) {
      const s = o[r];
      z(s != null, `No layout data found for index ${r}`);
      const u = s + a, f = H({
        panelConstraints: t[r],
        size: u
      });
      if (s !== f && (a -= f - s, o[r] = f, M(a, 0)))
        break;
    }
  const l = Object.keys(e);
  return o.reduce((r, s, u) => (r[l[u]] = s, r), {});
}
function Ie({
  groupId: e
}) {
  const t = () => {
    const { mountedGroups: n } = D();
    for (const [o, i] of n)
      if (o.id === e)
        return { group: o, ...i };
    throw Error(`Could not find Group with id "${e}"`);
  };
  return {
    getLayout() {
      const { defaultLayoutDeferred: n, layout: o } = t();
      return n ? {} : o;
    },
    setLayout(n) {
      const {
        defaultLayoutDeferred: o,
        derivedPanelConstraints: i,
        group: a,
        layout: l,
        separatorToPanels: r
      } = t(), s = F({
        layout: n,
        panelConstraints: i
      });
      return o ? l : (U(l, s) || I((u) => ({
        mountedGroups: new Map(u.mountedGroups).set(a, {
          defaultLayoutDeferred: o,
          derivedPanelConstraints: i,
          layout: s,
          separatorToPanels: r
        })
      })), s);
    }
  };
}
function Ge(e) {
  const { mountedGroups: t } = D(), n = t.get(e);
  return z(n, `Mounted Group ${e.id} not found`), n;
}
function _(e, t) {
  const n = ee(e), o = Ge(n), i = n.separators.find(
    (p) => p.element === e
  );
  z(i, "Matching separator not found");
  const a = o.separatorToPanels.get(i);
  z(a, "Matching panels not found");
  const l = a.map((p) => n.panels.indexOf(p)), s = Ie({ groupId: n.id }).getLayout(), u = q({
    delta: t,
    initialLayout: s,
    panelConstraints: o.derivedPanelConstraints,
    pivotIndices: l,
    prevLayout: s,
    trigger: "keyboard"
  }), f = F({
    layout: u,
    panelConstraints: o.derivedPanelConstraints
  });
  U(s, f) || I((p) => ({
    mountedGroups: new Map(p.mountedGroups).set(n, {
      defaultLayoutDeferred: o.defaultLayoutDeferred,
      derivedPanelConstraints: o.derivedPanelConstraints,
      layout: f,
      separatorToPanels: o.separatorToPanels
    })
  }));
}
function he(e) {
  if (e.defaultPrevented)
    return;
  const t = e.currentTarget, n = ee(t);
  if (!n.disabled)
    switch (e.key) {
      case "ArrowDown": {
        e.preventDefault(), n.orientation === "vertical" && _(t, 5);
        break;
      }
      case "ArrowLeft": {
        e.preventDefault(), n.orientation === "horizontal" && _(t, -5);
        break;
      }
      case "ArrowRight": {
        e.preventDefault(), n.orientation === "horizontal" && _(t, 5);
        break;
      }
      case "ArrowUp": {
        e.preventDefault(), n.orientation === "vertical" && _(t, -5);
        break;
      }
      case "End": {
        e.preventDefault(), _(t, 100);
        break;
      }
      case "Enter": {
        e.preventDefault();
        const o = ee(t), { derivedPanelConstraints: i, layout: a, separatorToPanels: l } = Ge(o), r = o.separators.find(
          (p) => p.element === t
        );
        z(r, "Matching separator not found");
        const s = l.get(r);
        z(s, "Matching panels not found");
        const u = s[0], f = i.find(
          (p) => p.panelId === u.id
        );
        if (z(f, "Panel metadata not found"), f.collapsible) {
          const p = a[u.id], h = f.collapsedSize === p ? o.inMemoryLastExpandedPanelSizes[u.id] ?? f.minSize : f.collapsedSize;
          _(t, h - p);
        }
        break;
      }
      case "F6": {
        e.preventDefault();
        const i = ee(t).separators.map(
          (s) => s.element
        ), a = Array.from(i).findIndex(
          (s) => s === e.currentTarget
        );
        z(a !== null, "Index not found");
        const l = e.shiftKey ? a > 0 ? a - 1 : i.length - 1 : a + 1 < i.length ? a + 1 : 0;
        i[l].focus();
        break;
      }
      case "Home": {
        e.preventDefault(), _(t, -100);
        break;
      }
    }
}
const it = (e) => e, ie = () => {
}, De = 1, Oe = 2, Te = 4, Ne = 8, me = {
  coarse: 10,
  precise: 5
};
function st(e, t, n) {
  let o, i = {
    x: 1 / 0,
    y: 1 / 0
  };
  for (const a of t) {
    const l = Ee(n, a.rect);
    switch (e) {
      case "horizontal": {
        l.x <= i.x && (o = a, i = l);
        break;
      }
      case "vertical": {
        l.y <= i.y && (o = a, i = l);
        break;
      }
    }
  }
  return o ? {
    distance: i,
    hitRegion: o
  } : void 0;
}
let Q;
function at() {
  return Q === void 0 && (typeof matchMedia == "function" ? Q = !!matchMedia("(pointer:coarse)").matches : Q = !1), Q;
}
function lt(e) {
  return e !== null && typeof e == "object" && "nodeType" in e && e.nodeType === Node.DOCUMENT_FRAGMENT_NODE;
}
function ut(e, t) {
  if (e === t) throw new Error("Cannot compare node with itself");
  const n = {
    a: Se(e),
    b: Se(t)
  };
  let o;
  for (; n.a.at(-1) === n.b.at(-1); )
    e = n.a.pop(), t = n.b.pop(), o = e;
  z(
    o,
    "Stacking order can only be calculated for elements with a common ancestor"
  );
  const i = {
    a: ge(ye(n.a)),
    b: ge(ye(n.b))
  };
  if (i.a === i.b) {
    const a = o.childNodes, l = {
      a: n.a.at(-1),
      b: n.b.at(-1)
    };
    let r = a.length;
    for (; r--; ) {
      const s = a[r];
      if (s === l.a) return 1;
      if (s === l.b) return -1;
    }
  }
  return Math.sign(i.a - i.b);
}
const ct = /\b(?:position|zIndex|opacity|transform|webkitTransform|mixBlendMode|filter|webkitFilter|isolation)\b/;
function ft(e) {
  const t = getComputedStyle(_e(e) ?? e).display;
  return t === "flex" || t === "inline-flex";
}
function dt(e) {
  const t = getComputedStyle(e);
  return !!(t.position === "fixed" || t.zIndex !== "auto" && (t.position !== "static" || ft(e)) || +t.opacity < 1 || "transform" in t && t.transform !== "none" || "webkitTransform" in t && t.webkitTransform !== "none" || "mixBlendMode" in t && t.mixBlendMode !== "normal" || "filter" in t && t.filter !== "none" || "webkitFilter" in t && t.webkitFilter !== "none" || "isolation" in t && t.isolation === "isolate" || ct.test(t.willChange) || t.webkitOverflowScrolling === "touch");
}
function ye(e) {
  let t = e.length;
  for (; t--; ) {
    const n = e[t];
    if (z(n, "Missing node"), dt(n)) return n;
  }
  return null;
}
function ge(e) {
  return e && Number(getComputedStyle(e).zIndex) || 0;
}
function Se(e) {
  const t = [];
  for (; e; )
    t.push(e), e = _e(e);
  return t;
}
function _e(e) {
  const { parentNode: t } = e;
  return lt(t) ? t.host : t;
}
function pt(e, t) {
  return e.x < t.x + t.width && e.x + e.width > t.x && e.y < t.y + t.height && e.y + e.height > t.y;
}
function ht({
  groupElement: e,
  hitRegion: t,
  pointerEventTarget: n
}) {
  if (!Me(n) || n.contains(e) || e.contains(n))
    return !0;
  if (ut(n, e) > 0) {
    let o = n;
    for (; o; ) {
      if (o.contains(e))
        return !0;
      if (pt(o.getBoundingClientRect(), t))
        return !1;
      o = o.parentElement;
    }
  }
  return !0;
}
function Ae(e, t) {
  const n = [];
  return t.forEach((o, i) => {
    if (i.disabled)
      return;
    const a = at() ? me.coarse : me.precise, l = ke(i), r = st(i.orientation, l, {
      x: e.clientX,
      y: e.clientY
    });
    r && r.distance.x <= a && r.distance.y <= a && ht({
      groupElement: i.element,
      hitRegion: r.hitRegion.rect,
      pointerEventTarget: e.target
    }) && n.push(r.hitRegion);
  }), n;
}
function ve(e) {
  if (e.defaultPrevented)
    return;
  if (e.pointerType === "mouse" && e.button > 0)
    return;
  const { mountedGroups: t } = D(), n = Ae(e, t), o = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), a = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Map();
  let r = !1;
  n.forEach((s) => {
    o.add(s.group), s.panels.forEach((f) => {
      i.add(f);
    }), s.separator && (a.add(s.separator), r || (r = !0, s.separator.element.focus()));
    const u = t.get(s.group);
    u && l.set(s.group, u.layout);
  }), I({
    interactionState: {
      hitRegions: n,
      initialLayoutMap: l,
      pointerDownAtPoint: { x: e.clientX, y: e.clientY },
      state: "active"
    }
  }), n.length && e.preventDefault();
}
function mt({
  cursorFlags: e,
  groups: t,
  state: n
}) {
  let o = 0, i = 0;
  switch (n) {
    case "active":
    case "hover":
      t.forEach((a) => {
        if (!a.disableCursor)
          switch (a.orientation) {
            case "horizontal": {
              o++;
              break;
            }
            case "vertical": {
              i++;
              break;
            }
          }
      });
  }
  if (o === 0 && i === 0)
    return null;
  switch (n) {
    case "active": {
      const a = (e & De) !== 0, l = (e & Oe) !== 0, r = (e & Te) !== 0, s = (e & Ne) !== 0;
      if (e) {
        if (a)
          return r ? "se-resize" : s ? "ne-resize" : "e-resize";
        if (l)
          return r ? "sw-resize" : s ? "nw-resize" : "w-resize";
        if (r)
          return "s-resize";
        if (s)
          return "n-resize";
      }
      break;
    }
  }
  return o > 0 && i > 0 ? "move" : o > 0 ? "ew-resize" : "ns-resize";
}
const xe = /* @__PURE__ */ new WeakMap();
function ue(e) {
  if (e.defaultView === null || e.defaultView === void 0)
    return;
  let { prevStyle: t, styleSheet: n } = xe.get(e) ?? {};
  n === void 0 && (n = new e.defaultView.CSSStyleSheet(), e.adoptedStyleSheets = [n]);
  const { cursorFlags: o, interactionState: i } = D();
  switch (i.state) {
    case "active":
    case "hover": {
      const a = mt({
        cursorFlags: o,
        groups: i.hitRegions.map((r) => r.group),
        state: i.state
      }), l = `*{cursor: ${a} !important; ${i.state === "active" ? "touch-action: none;" : ""} }`;
      if (t === l)
        return;
      t = l, a ? n.cssRules.length === 0 ? n.insertRule(l) : n.replaceSync(l) : n.cssRules.length === 1 && n.deleteRule(0);
      break;
    }
    case "inactive": {
      t = void 0, n.cssRules.length === 1 && n.deleteRule(0);
      break;
    }
  }
  xe.set(e, {
    prevStyle: t,
    styleSheet: n
  });
}
function Fe({
  document: e,
  event: t,
  hitRegions: n,
  initialLayoutMap: o,
  mountedGroups: i,
  pointerDownAtPoint: a
}) {
  let l = 0;
  const r = new Map(i);
  n.forEach((s) => {
    const { group: u, groupSize: f } = s, { disableCursor: p, orientation: h, panels: m } = u;
    let c = 0;
    a ? h === "horizontal" ? c = (t.clientX - a.x) / f * 100 : c = (t.clientY - a.y) / f * 100 : h === "horizontal" ? c = t.clientX < 0 ? -100 : 100 : c = t.clientY < 0 ? -100 : 100;
    const d = o.get(u), {
      defaultLayoutDeferred: S,
      derivedPanelConstraints: y,
      layout: v,
      separatorToPanels: x
    } = i.get(u) ?? { defaultLayoutDeferred: !1 };
    if (y && d && v && x) {
      const g = q({
        delta: c,
        initialLayout: d,
        panelConstraints: y,
        pivotIndices: s.panels.map((L) => m.indexOf(L)),
        prevLayout: v,
        trigger: "mouse-or-touch"
      });
      if (U(g, v)) {
        if (c !== 0 && !p)
          switch (h) {
            case "horizontal": {
              l |= c < 0 ? De : Oe;
              break;
            }
            case "vertical": {
              l |= c < 0 ? Te : Ne;
              break;
            }
          }
      } else {
        r.set(s.group, {
          defaultLayoutDeferred: S,
          derivedPanelConstraints: y,
          layout: g,
          separatorToPanels: x
        });
        const L = s.group.panels.map(({ id: P }) => P).join(",");
        s.group.inMemoryLayouts[L] = g;
      }
    }
  }), I({
    cursorFlags: l,
    mountedGroups: r
  }), ue(e);
}
function ze(e) {
  const { interactionState: t, mountedGroups: n } = D();
  switch (t.state) {
    case "active":
      Fe({
        document: e.currentTarget,
        event: e,
        hitRegions: t.hitRegions,
        initialLayoutMap: t.initialLayoutMap,
        mountedGroups: n
      });
  }
}
function be(e) {
  if (e.defaultPrevented)
    return;
  const { interactionState: t, mountedGroups: n } = D();
  switch (t.state) {
    case "active": {
      if (
        // Skip this check for "pointerleave" events, else Firefox triggers a false positive (see #514)
        e.buttons === 0
      ) {
        I(
          (o) => o.interactionState.state === "inactive" ? o : {
            cursorFlags: 0,
            interactionState: {
              state: "inactive"
            }
          }
        );
        return;
      }
      Fe({
        document: e.currentTarget,
        event: e,
        hitRegions: t.hitRegions,
        initialLayoutMap: t.initialLayoutMap,
        mountedGroups: n,
        pointerDownAtPoint: t.pointerDownAtPoint
      });
      break;
    }
    default: {
      const o = Ae(e, n);
      o.length === 0 ? t.state !== "inactive" && I({
        interactionState: { state: "inactive" }
      }) : I({
        interactionState: {
          hitRegions: o,
          state: "hover"
        }
      }), ue(e.currentTarget);
      break;
    }
  }
}
function we(e) {
  if (e.defaultPrevented)
    return;
  if (e.pointerType === "mouse" && e.button > 0)
    return;
  const { interactionState: t } = D();
  switch (t.state) {
    case "active":
      I({
        cursorFlags: 0,
        interactionState: {
          state: "inactive"
        }
      }), t.hitRegions.length > 0 && (ue(e.currentTarget), e.preventDefault());
  }
}
function Le(e) {
  let t = 0, n = 0;
  const o = {};
  for (const a of e)
    if (a.defaultSize !== void 0) {
      t++;
      const l = G(a.defaultSize);
      n += l, o[a.panelId] = l;
    } else
      o[a.panelId] = void 0;
  const i = e.length - t;
  if (i !== 0) {
    const a = G((100 - n) / i);
    for (const l of e)
      l.defaultSize === void 0 && (o[l.panelId] = a);
  }
  return o;
}
function yt(e, t, n) {
  if (!n[0])
    return;
  const i = e.panels.find((u) => u.element === t);
  if (!i || !i.onResize)
    return;
  const a = V({ group: e }), l = e.orientation === "horizontal" ? i.element.offsetWidth : i.element.offsetHeight, r = i.mutableValues.prevSize, s = {
    asPercentage: G(l / a * 100),
    inPixels: l
  };
  i.mutableValues.prevSize = s, i.onResize(s, i.id, r);
}
function gt(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length)
    return !1;
  for (const o in e)
    if (e[o] !== t[o])
      return !1;
  return !0;
}
function St(e, t) {
  const n = e.map((i) => i.id), o = Object.keys(t);
  if (n.length !== o.length)
    return !1;
  for (const i of n)
    if (!o.includes(i))
      return !1;
  return !0;
}
const j = /* @__PURE__ */ new Map();
function vt(e) {
  let t = !0;
  z(
    e.element.ownerDocument.defaultView,
    "Cannot register an unmounted Group"
  );
  const n = e.element.ownerDocument.defaultView.ResizeObserver, o = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Set(), a = new n((c) => {
    for (const d of c) {
      const { borderBoxSize: S, target: y } = d;
      if (y === e.element) {
        if (t) {
          if (V({ group: e }) === 0)
            return;
          I((x) => {
            const g = x.mountedGroups.get(e);
            if (g) {
              const L = pe(e), P = g.defaultLayoutDeferred ? Le(L) : g.layout, R = F({
                layout: P,
                panelConstraints: L
              });
              return !g.defaultLayoutDeferred && U(P, R) && gt(
                g.derivedPanelConstraints,
                L
              ) ? x : {
                mountedGroups: new Map(x.mountedGroups).set(e, {
                  defaultLayoutDeferred: !1,
                  derivedPanelConstraints: L,
                  layout: R,
                  separatorToPanels: g.separatorToPanels
                })
              };
            }
            return x;
          });
        }
      } else
        yt(e, y, S);
    }
  });
  a.observe(e.element), e.panels.forEach((c) => {
    z(
      !o.has(c.id),
      `Panel ids must be unique; id "${c.id}" was used more than once`
    ), o.add(c.id), c.onResize && a.observe(c.element);
  });
  const l = V({ group: e }), r = pe(e), s = e.panels.map(({ id: c }) => c).join(",");
  let u = e.defaultLayout;
  u && (St(e.panels, u) || (u = void 0));
  const f = e.inMemoryLayouts[s] ?? u ?? Le(r), p = F({
    layout: f,
    panelConstraints: r
  }), h = ke(e), m = e.element.ownerDocument;
  return I((c) => {
    const d = /* @__PURE__ */ new Map();
    return j.set(
      m,
      (j.get(m) ?? 0) + 1
    ), h.forEach((S) => {
      S.separator && d.set(S.separator, S.panels);
    }), {
      mountedGroups: new Map(c.mountedGroups).set(e, {
        defaultLayoutDeferred: l === 0,
        derivedPanelConstraints: r,
        layout: p,
        separatorToPanels: d
      })
    };
  }), e.separators.forEach((c) => {
    z(
      !i.has(c.id),
      `Separator ids must be unique; id "${c.id}" was used more than once`
    ), i.add(c.id), c.element.addEventListener("keydown", he);
  }), j.get(m) === 1 && (m.addEventListener("pointerdown", ve, !0), m.addEventListener("pointerleave", ze), m.addEventListener("pointermove", be), m.addEventListener("pointerup", we, !0)), function() {
    t = !1, j.set(
      m,
      Math.max(0, (j.get(m) ?? 0) - 1)
    ), I((d) => {
      const S = new Map(d.mountedGroups);
      return S.delete(e), { mountedGroups: S };
    }), e.separators.forEach((d) => {
      d.element.removeEventListener("keydown", he);
    }), j.get(m) || (m.removeEventListener(
      "pointerdown",
      ve,
      !0
    ), m.removeEventListener("pointerleave", ze), m.removeEventListener("pointermove", be), m.removeEventListener("pointerup", we, !0)), a.disconnect();
  };
}
function $e() {
  const [e, t] = K({}), n = Pe(() => t({}), []);
  return [e, n];
}
function ce(e) {
  const t = Ue();
  return `${e ?? t}`;
}
const $ = typeof window < "u" ? We : Re;
function te(e) {
  const t = k(e);
  return $(() => {
    t.current = e;
  }, [e]), Pe(
    (...n) => t.current?.(...n),
    [t]
  );
}
function fe(...e) {
  return te((t) => {
    e.forEach((n) => {
      if (n)
        switch (typeof n) {
          case "function": {
            n(t);
            break;
          }
          case "object": {
            n.current = t;
            break;
          }
        }
    });
  });
}
function xt(e) {
  const t = k({ ...e });
  return $(() => {
    for (const n in e)
      t.current[n] = e[n];
  }, [e]), t.current;
}
const je = Be(null);
function zt(e, t) {
  const n = k({
    getLayout: () => ({}),
    setLayout: it
  });
  Ce(t, () => n.current, []), $(() => {
    Object.assign(
      n.current,
      Ie({ groupId: e })
    );
  });
}
function bt({
  children: e,
  className: t,
  defaultLayout: n,
  disableCursor: o,
  disabled: i,
  elementRef: a,
  groupRef: l,
  id: r,
  onLayoutChange: s,
  orientation: u = "horizontal",
  style: f,
  ...p
}) {
  const h = k({}), m = te((b) => {
    U(h.current, b) || (h.current = b, s?.(b));
  }), c = ce(r), d = k(null), [S, y] = $e(), v = k({
    lastExpandedPanelSizes: {},
    layouts: {},
    panels: [],
    separators: []
  }), x = fe(d, a);
  zt(c, l);
  const g = te(
    (b, w) => {
      const { interactionState: C, mountedGroups: O } = D();
      for (const T of O.keys())
        if (T.id === b) {
          const N = O.get(T);
          if (N) {
            let Y = !1;
            switch (C.state) {
              case "active": {
                Y = C.hitRegions.some(
                  (ne) => ne.group === T
                );
                break;
              }
            }
            return {
              flexGrow: N.layout[w] ?? 1,
              pointerEvents: Y ? "none" : void 0
            };
          }
        }
      return {
        flexGrow: n?.[w] ?? 1
      };
    }
  ), L = ae(
    () => ({
      getPanelStyles: g,
      id: c,
      orientation: u,
      registerPanel: (b) => {
        const w = v.current;
        return w.panels = le(u, [
          ...w.panels,
          b
        ]), y(), () => {
          w.panels = w.panels.filter(
            (C) => C !== b
          ), y();
        };
      },
      registerSeparator: (b) => {
        const w = v.current;
        return w.separators = le(u, [
          ...w.separators,
          b
        ]), y(), () => {
          w.separators = w.separators.filter(
            (C) => C !== b
          ), y();
        };
      }
    }),
    [g, c, y, u]
  ), P = xt({
    defaultLayout: n,
    disableCursor: o
  }), R = k(null);
  return $(() => {
    const b = d.current;
    if (b === null)
      return;
    const w = v.current, C = {
      defaultLayout: P.defaultLayout,
      disableCursor: !!P.disableCursor,
      disabled: !!i,
      element: b,
      id: c,
      inMemoryLastExpandedPanelSizes: v.current.lastExpandedPanelSizes,
      inMemoryLayouts: v.current.layouts,
      orientation: u,
      panels: w.panels,
      separators: w.separators
    };
    R.current = C;
    const O = vt(C), N = D().mountedGroups.get(C);
    if (N) {
      const { defaultLayoutDeferred: W, derivedPanelConstraints: J, layout: oe } = N;
      !W && J.length > 0 && (m?.(oe), w.panels.forEach((re) => {
        re.scheduleUpdate();
      }));
    }
    const Y = A.addListener(
      "interactionStateChange",
      () => {
        w.panels.forEach((W) => {
          W.scheduleUpdate();
        });
      }
    ), ne = A.addListener(
      "mountedGroupsChange",
      (W) => {
        const J = W.get(C);
        if (J) {
          const { defaultLayoutDeferred: oe, derivedPanelConstraints: re, layout: He } = J;
          if (oe || re.length === 0)
            return;
          m?.(He), w.panels.forEach((Ve) => {
            Ve.scheduleUpdate();
          });
        }
      }
    );
    return () => {
      R.current = null, O(), Y(), ne();
    };
  }, [
    i,
    c,
    m,
    u,
    S,
    P
  ]), Re(() => {
    const b = R.current;
    b && (b.defaultLayout = n, b.disableCursor = !!o);
  }), /* @__PURE__ */ B(je.Provider, { value: L, children: /* @__PURE__ */ B(
    "div",
    {
      ...p,
      "aria-orientation": u,
      className: t,
      "data-group": !0,
      "data-testid": c,
      id: c,
      ref: x,
      style: {
        height: "100%",
        width: "100%",
        overflow: "hidden",
        ...f,
        display: "flex",
        flexDirection: u === "horizontal" ? "row" : "column",
        flexWrap: "nowrap"
      },
      children: e
    }
  ) });
}
bt.displayName = "Group";
function wt(e, t = 10) {
  let n = null;
  return (o) => {
    n !== null && clearTimeout(n), n = setTimeout(() => {
      e(o);
    }, t);
  };
}
function se(e, t) {
  return `react-resizable-panels:${[e, ...t].join(":")}`;
}
function Dt({
  debounceSaveMs: e = 100,
  panelIds: t,
  storage: n = localStorage,
  ...o
}) {
  const i = t !== void 0, a = "id" in o ? o.id : o.groupId, l = se(a, t ?? []), r = Ke(
    Lt,
    () => n.getItem(l),
    () => n.getItem(l)
  ), s = ae(
    () => r ? JSON.parse(r) : void 0,
    [r]
  ), u = ae(() => {
    const f = (p) => {
      let h;
      i ? h = se(a, Object.keys(p)) : h = se(a, []);
      try {
        n.setItem(h, JSON.stringify(p));
      } catch (m) {
        console.error(m);
      }
    };
    return e > 0 ? wt(f, e) : f;
  }, [e, i, a, n]);
  return {
    defaultLayout: s,
    onLayoutChange: u
  };
}
function Lt() {
  return function() {
  };
}
function Ot() {
  return K(null);
}
function Tt() {
  return k(null);
}
function de() {
  const e = Xe(je);
  return z(
    e,
    "Group Context not found; did you render a Panel or Separator outside of a Group?"
  ), e;
}
function Pt({
  groupId: e,
  panelId: t
}) {
  const n = () => {
    const { mountedGroups: r } = D();
    for (const [
      s,
      {
        defaultLayoutDeferred: u,
        derivedPanelConstraints: f,
        layout: p,
        separatorToPanels: h
      }
    ] of r)
      if (s.id === e)
        return {
          defaultLayoutDeferred: u,
          derivedPanelConstraints: f,
          group: s,
          layout: p,
          separatorToPanels: h
        };
    throw Error(`Group ${e} not found`);
  }, o = () => {
    const r = n().derivedPanelConstraints.find(
      (s) => s.panelId === t
    );
    if (r !== void 0)
      return r;
    throw Error(`Panel constraints not found for Panel ${t}`);
  }, i = () => {
    const r = n().group.panels.find((s) => s.id === t);
    if (r !== void 0)
      return r;
    throw Error(`Layout not found for Panel ${t}`);
  }, a = () => {
    const r = n().layout[t];
    if (r !== void 0)
      return r;
    throw Error(`Layout not found for Panel ${t}`);
  }, l = (r) => {
    const s = a();
    if (r === s)
      return;
    const {
      defaultLayoutDeferred: u,
      derivedPanelConstraints: f,
      group: p,
      layout: h,
      separatorToPanels: m
    } = n(), c = p.panels.findIndex((v) => v.id === t), d = c === p.panels.length - 1, S = q({
      delta: d ? s - r : r - s,
      initialLayout: h,
      panelConstraints: f,
      pivotIndices: d ? [c - 1, c] : [c, c + 1],
      prevLayout: h,
      trigger: "imperative-api"
    }), y = F({
      layout: S,
      panelConstraints: f
    });
    U(h, y) || I((v) => ({
      mountedGroups: new Map(v.mountedGroups).set(p, {
        defaultLayoutDeferred: u,
        derivedPanelConstraints: f,
        layout: y,
        separatorToPanels: m
      })
    }));
  };
  return {
    collapse: () => {
      const { collapsible: r, collapsedSize: s } = o(), { mutableValues: u } = i(), f = a();
      r && f !== s && (u.expandToSize = f, l(s));
    },
    expand: () => {
      const { collapsible: r, collapsedSize: s, minSize: u } = o(), { mutableValues: f } = i(), p = a();
      if (r && p === s) {
        let h = f.expandToSize ?? u;
        h === 0 && (h = 1), l(h);
      }
    },
    getSize: () => {
      const { group: r } = n(), s = a(), { element: u } = i(), f = r.orientation === "horizontal" ? u.offsetWidth : u.offsetHeight;
      return {
        asPercentage: s,
        inPixels: f
      };
    },
    isCollapsed: () => {
      const { collapsible: r, collapsedSize: s } = o(), u = a();
      return r && M(s, u);
    },
    resize: (r) => {
      if (a() !== r) {
        let u;
        switch (typeof r) {
          case "number": {
            const { group: f } = n(), p = V({ group: f });
            u = G(r / p * 100);
            break;
          }
          case "string": {
            u = parseFloat(r);
            break;
          }
        }
        l(u);
      }
    }
  };
}
function Rt(e, t) {
  const { id: n } = de(), o = k({
    collapse: ie,
    expand: ie,
    getSize: () => ({
      asPercentage: 0,
      inPixels: 0
    }),
    isCollapsed: () => !1,
    resize: ie
  });
  Ce(t, () => o.current, []), $(() => {
    Object.assign(
      o.current,
      Pt({ groupId: n, panelId: e })
    );
  });
}
function Ct({
  children: e,
  className: t,
  collapsedSize: n = "0%",
  collapsible: o = !1,
  defaultSize: i,
  elementRef: a,
  id: l,
  maxSize: r = "100%",
  minSize: s = "0%",
  onResize: u,
  panelRef: f,
  style: p,
  ...h
}) {
  const m = !!l, c = ce(l), d = k(null), S = fe(d, a), [, y] = $e(), { getPanelStyles: v, id: x, registerPanel: g } = de(), L = u !== null, P = te(
    (b, w, C) => {
      u?.(b, l, C);
    }
  );
  $(() => {
    const b = d.current;
    if (b !== null)
      return g({
        element: b,
        id: c,
        idIsStable: m,
        mutableValues: {
          expandToSize: void 0,
          prevSize: void 0
        },
        onResize: L ? P : void 0,
        panelConstraints: {
          collapsedSize: n,
          collapsible: o,
          defaultSize: i,
          maxSize: r,
          minSize: s
        },
        scheduleUpdate: y
      });
  }, [
    n,
    o,
    i,
    y,
    L,
    c,
    m,
    r,
    s,
    P,
    g
  ]), Rt(c, f);
  const R = v(x, c);
  return /* @__PURE__ */ B(
    "div",
    {
      ...h,
      "data-panel": !0,
      "data-testid": c,
      id: c,
      ref: S,
      style: {
        ...Mt,
        flexBasis: 0,
        flexShrink: 1,
        // Prevent Panel content from interfering with panel size
        overflow: "hidden",
        ...R
      },
      children: /* @__PURE__ */ B(
        "div",
        {
          className: t,
          style: {
            width: "100%",
            height: "100%",
            ...p
          },
          children: e
        }
      )
    }
  );
}
Ct.displayName = "Panel";
const Mt = {
  minHeight: 0,
  maxHeight: "100%",
  height: "auto",
  minWidth: 0,
  maxWidth: "100%",
  width: "auto",
  border: "none",
  borderWidth: 0,
  padding: 0,
  margin: 0
};
function Nt() {
  return K(null);
}
function _t() {
  return k(null);
}
function Et({
  layout: e,
  panelConstraints: t,
  panelId: n,
  panelIndex: o
}) {
  let i, a;
  const l = e[n], r = t.find(
    (s) => s.panelId === n
  );
  if (r) {
    const s = r.maxSize, u = a = r.collapsible ? r.collapsedSize : r.minSize, f = [o, o + 1];
    a = F({
      layout: q({
        delta: u - l,
        initialLayout: e,
        panelConstraints: t,
        pivotIndices: f,
        prevLayout: e,
        trigger: "keyboard"
      }),
      panelConstraints: t
    })[n], i = F({
      layout: q({
        delta: s - l,
        initialLayout: e,
        panelConstraints: t,
        pivotIndices: f,
        prevLayout: e,
        trigger: "keyboard"
      }),
      panelConstraints: t
    })[n];
  }
  return {
    valueControls: n,
    valueMax: i,
    valueMin: a,
    valueNow: l
  };
}
function kt({
  children: e,
  className: t,
  elementRef: n,
  id: o,
  style: i,
  ...a
}) {
  const l = ce(o), [r, s] = K({}), [u, f] = K("inactive"), p = k(null), h = fe(p, n), {
    id: m,
    orientation: c,
    registerSeparator: d
  } = de(), S = c === "horizontal" ? "vertical" : "horizontal";
  return $(() => {
    const y = p.current;
    if (y !== null) {
      const v = {
        element: y,
        id: l
      }, x = d(v), g = A.addListener(
        "interactionStateChange",
        (P) => {
          f(
            P.state !== "inactive" && P.hitRegions.some(
              (R) => R.separator === v
            ) ? P.state : "inactive"
          );
        }
      ), L = A.addListener(
        "mountedGroupsChange",
        (P) => {
          P.forEach(
            ({ derivedPanelConstraints: R, layout: b, separatorToPanels: w }, C) => {
              if (C.id === m) {
                const O = w.get(v);
                if (O) {
                  const T = O[0], N = C.panels.indexOf(T);
                  s(
                    Et({
                      layout: b,
                      panelConstraints: R,
                      panelId: T.id,
                      panelIndex: N
                    })
                  );
                }
              }
            }
          );
        }
      );
      return () => {
        g(), L(), x();
      };
    }
  }, [m, l, d]), /* @__PURE__ */ B(
    "div",
    {
      ...a,
      "aria-controls": r.valueControls,
      "aria-orientation": S,
      "aria-valuemax": r.valueMax,
      "aria-valuemin": r.valueMin,
      "aria-valuenow": r.valueNow,
      children: e,
      className: t,
      "data-separator": u,
      "data-testid": l,
      id: l,
      ref: h,
      role: "separator",
      style: {
        flexBasis: "auto",
        ...i,
        flexGrow: 0,
        flexShrink: 0
      },
      tabIndex: 0
    }
  );
}
kt.displayName = "Separator";
export {
  bt as Group,
  Ct as Panel,
  kt as Separator,
  Dt as useDefaultLayout,
  Ot as useGroupCallbackRef,
  Tt as useGroupRef,
  Nt as usePanelCallbackRef,
  _t as usePanelRef
};
//# sourceMappingURL=react-resizable-panels.js.map
